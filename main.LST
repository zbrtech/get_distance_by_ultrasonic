C51 COMPILER V9.00   MAIN                                                                  12/20/2016 00:39:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <AT89x51.H>            //器件配置文件
   2          #include <intrins.h>
   3          
   4          #define TRIG P1_1       //分别给超声波发射口和接受口设置别名，
   5          #define ECHO P1_2       //这里11 12引脚可以随便使用，只要是P1~P3间的IO口就行
   6          
   7          //下面是对1602显示频引脚的定义
   8          //这里较为固定，因为我们接的就是最后一排那个接口，
   9          //所以这里需要查看一下开发板的原理图
  10          #define LCM_EN P0_5  //显示器的使能端
  11          #define LCM_RS P0_7      //寄存器选择
  12          #define LCM_RW P0_6  //读写选择线
  13          #define LCM_DATA P2      //数据选择线，共有P20-P28个数据选择端
  14          
  15          #define BUSY 0x80   //用来检测LCM是否是busy表示，读取BF字段的值
  16          typedef bit BOOL;
  17          
  18          /*
  19          1602基本的引脚功能：
  20          第1脚：VSS为电源地
  21          第2脚：VCC接5V电源正极
  22          第4脚：RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器。
  23          第5脚：RW为读写信号线，高电平(1)时进行读操作，低电平(0)时进行写操作。
  24          第6脚：E(或EN)端为使能(enable)端,高电平（1）时读取信息
  25          第7～14脚：D0～D7为8位双向数据端。
  26          */
  27          
  28          //因为单片机执行是有时间延迟的，所以很多时候都要加一个延时的设置
  29          //延迟时间和晶振频率有关，（具体不知道）ps至少延时大于100个执行时间
  30          void delay_ms(int time)
  31          {
  32   1              unsigned int time1 = time;
  33   1              unsigned int time2 = 100;
  34   1              while(time1) time1--;
  35   1              while(time2--);
  36   1      }
  37          
  38          BOOL get_busy_status(void)
  39          {
  40   1              BOOL result;
  41   1              LCM_DATA = 0xff;
  42   1              LCM_RS = 0;     //选择指令寄存器
  43   1              LCM_RW = 1;    //读操作
  44   1              LCM_EN = 0;
  45   1              delay_ms(50);
  46   1              LCM_EN = 1;
  47   1              result = LCM_DATA & BUSY; //检测忙信号,如果忙碌就一直等待
  48   1              return result;
  49   1      }
  50          
  51          
  52          //写指令
  53          void write_command(unsigned char WCLCM, busy)//当busy为0的时候不检查是否忙碌
  54          {
  55   1              while(get_busy_status());
C51 COMPILER V9.00   MAIN                                                                  12/20/2016 00:39:08 PAGE 2   

  56   1              LCM_DATA = WCLCM;
  57   1              LCM_RS = 0;    //选择指令寄存器
  58   1              LCM_RW = 0;    //选择写操作，这里是写操作字
  59   1              LCM_EN = 0;             //在这里起一个延时的作用
  60   1              delay_ms(50);   //作用和上面其实是一样的
  61   1              LCM_EN = 1;    //执行指令
  62   1      }
  63          
  64          //写数据
  65          void write_data(unsigned char WRLCM)
  66          {
  67   1              while(get_busy_status());
  68   1              LCM_DATA = WRLCM;
  69   1              LCM_RS = 1;  //因为是写操作，所以要选择数据寄存器
  70   1              LCM_RW = 0;  //写操作
  71   1              LCM_EN = 0;
  72   1              delay_ms(50);
  73   1              LCM_EN = 1;
  74   1      }
  75          
  76          
  77          //读数据
  78          unsigned char read_data(void)
  79          {
  80   1              LCM_RS = 1;
  81   1              LCM_RW = 1;  //读操作
  82   1              LCM_EN = 0;
  83   1              delay_ms(50);
  84   1              LCM_EN = 1;
  85   1              return LCM_DATA;
  86   1      }
  87          
  88          //初始化
  89          void LCM_init(void)
  90          {
  91   1              LCM_DATA = 0;
  92   1              LCM_EN = 0;
  93   1              /*0x38  00111000  设置16*2显示  5*7点阵  8位数据接口*/  
  94   1              write_command(0x38, 0);
  95   1              delay_ms(50);
  96   1      
  97   1              write_command(0x38, 1);
  98   1              delay_ms(50);
  99   1              write_command(0x0e, 1); //设置显示光标
 100   1              write_command(0x01, 1); //清屏一波
 101   1              write_command(0x06, 1); //地址指针自动+1且光标+1 
 102   1              write_command(0x80, 1); //设置初始显示位置，这一步好像可以不要，
 103   1                                                              //后面肯定还要设置地址。
 104   1      }
 105          
 106          
 107          void display_one_char(unsigned char x, unsigned char y, unsigned char data_)
 108          {
 109   1              y &= 0x01;
 110   1              x &= 0x0f;              //限制x不能大于15
 111   1              if (y) x |= 0x40; //要显示第二行的时候
 112   1              x |= 0x80;
 113   1              write_command(x, 1);
 114   1              write_data(data_);
 115   1      }
 116          
 117          int main()
C51 COMPILER V9.00   MAIN                                                                  12/20/2016 00:39:08 PAGE 3   

 118          {
 119   1              delay_ms(400);
 120   1              LCM_init();
 121   1              delay_ms(400);
 122   1              display_one_char(0, 0, 'c');
 123   1              while(1);
 124   1              return 0;
 125   1      }
 126          
 127                          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    219    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
